/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package snakegame

import java.util.*

class SnakeGame(private val width: Int, private val height: Int, private val food: Array<IntArray>) {

    val snake = ArrayDeque(arrayListOf(intArrayOf(0,0)))
    val snakeMap = mutableMapOf<List<Int>, Boolean>()
    var foodIndex = 0

    fun move(direction: String): Int {

        val currentHead = snake.peekFirst()
        var newHeadRow = currentHead[0]
        var newHeadCol = currentHead[1]

        when (direction) {
            "U" -> newHeadRow--
            "D" -> newHeadRow++
            "L" -> newHeadCol--
            "R" -> newHeadCol++
        }

        val newHead = listOf(newHeadRow, newHeadCol)


        if (boundaryConditions(newHead))
            return -1

        if (!foundFood(newHead)) {
            val last = snake.pollLast()
            snakeMap.remove(listOf(last[0], last[1]))
        }
        snake.addFirst(newHead.toIntArray())
        snakeMap.put(newHead, true)

        return snake.size - 1
    }

    private fun foundFood(newHead: List<Int>): Boolean {
        if (foodIndex< food.size && (food[foodIndex][0] == newHead[0] && food[foodIndex][1] == newHead[1])) {
            foodIndex++
            return true
        }

        return false
    }

    private fun boundaryConditions(newHead: List<Int>): Boolean {
        if (newHead[0] < 0 || newHead[0] >= height)
            return true
        if (newHead[1] < 0 || newHead[1] >= width)
            return true

        val currentTail = snake.peekLast()
        if (snakeMap.containsKey(newHead) && !(newHead[0] == currentTail[0] && newHead[1] == currentTail[1]))
            return true

        return false
    }

}


fun main() {
    val snakeGame = SnakeGame(3, 2, arrayOf(intArrayOf(1, 2), intArrayOf(0, 1)))
    println(snakeGame.move("R"))
}
